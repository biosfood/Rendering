#pragma kernel trace
#pragma kernel reset

RWStructuredBuffer<float3> light;
int width, height;
float3 position, viewDirection;

struct Ray {
    float3 origin;
    float3 direction;
};

struct Material {
    float3 color;
};

struct RayHit {
    bool hit;
    float3 position, normal;
    float distance;
    Material material;
};

[numthreads(8,8,1)]
void reset(uint3 id : SV_DispatchThreadID) {
    int index = id.x + id.y * width;
    light[index] = float3(0, 0, 0);
}

RayHit testSphere(Ray ray) {
    RayHit result;
    result.hit = false;
    float3 p = float3(0, 1, 0);
    float3 ap = p-ray.origin;
    float r = 2;
    float b =  2 * dot(ap, ray.direction);
    float c = dot(ap,ap)-r*r;
    float D = b*b - 4*c;
    if (D < 0) {
        return result;
    }
    float lambda = (b - sqrt(D))/2;
    result.hit = lambda > 0;
    float3 x = ray.origin + lambda * ray.direction;
    result.normal = normalize(x-p);
    result.position = x;
    result.distance = lambda;
    Material material;
    material.color = result.normal;
    result.material = material;
    return result;
}

RayHit testFloor(Ray ray) {
    RayHit result;
    result.hit = ray.direction.y < 0;
    result.distance = -ray.origin.y / ray.direction.y;
    result.normal = float3(0, 1, 0);
    Material material;
    material.color = float3(0.2,0.2,0.2);
    result.material = material;
    return result;
}

void test(inout RayHit hit, RayHit test)  {
    if (test.hit && test.distance < hit.distance) {
        hit.hit = true;
        hit.distance = test.distance;
        hit.material = test.material;
        hit.normal = test.normal;
    }
}

RayHit cast(Ray ray) {
    RayHit hit;
    hit.distance = 10000.0;
    Material sky;
    sky.color = float3(0, 0, 0.8);
    hit.material = sky;
    hit.position = float3(0,0,0);
    hit.normal = float3(0,1,0);
    test(hit, testSphere(ray));
    test(hit, testFloor(ray));
    return hit;
}

[numthreads(8,8,1)]
void trace(uint3 id : SV_DispatchThreadID) {
    float3 up = float3(0, 1, 0);
    int index = id.x + id.y * width;
    float2 screenPosition = (id.xy / float2(width, height) * 2 - float2(1, 1)) * float2(float(width)/float(height), 1);
    float3 left = normalize(cross(up, viewDirection));
    float3 cameraUp = normalize(cross(viewDirection, left));
    float3 pixelDirection = normalize(viewDirection + screenPosition.x * left + screenPosition.y * cameraUp);
    Ray ray;
    ray.origin = position;
    ray.direction = pixelDirection;
    RayHit hit = cast(ray);
    light[index] += hit.material.color;
}