#pragma kernel trace
#pragma kernel reset

RWStructuredBuffer<float3> light;
int width, height,  bounces;
float3 position, viewDirection;
float3 up, sunDirection;
float sunStrength;

static const float PI = 3.14159265f;

struct Ray {
    float3 origin;
    float3 direction;
};

struct Material {
    float4 color;
    float specular;
};

RWStructuredBuffer<Material> materials;

struct RayHit {
    bool hit;
    float3 position, normal;
    float distance;
    Material material;
};

struct Sphere {
    float3 position;
    float radius;
    int material;
};

RWStructuredBuffer<Sphere> spheres;
int sphereCount;

uint Hash(inout uint s) {
    s ^= 2747636419u;
    s *= 2654435769u;
    s ^= s >> 16;
    s *= 2654435769u;
    s ^= s >> 16;
    s *= 2654435769u;
    return s;
}

float random(inout uint seed) {
    return float(Hash(seed)) / 4294967295.0;
}

float randomNormal(inout uint seed) {
    float theta = 2 * PI * random(seed);
    float rho = sqrt(-2*log(random(seed)));
    return rho * cos(theta);
}

float3 randomDirection(inout uint seed) {
    return normalize(float3(randomNormal(seed), randomNormal(seed), randomNormal(seed)));
}

float3 randomHemisphereDirection(inout uint seed, float3 normal) {
    float3 direction = randomDirection(seed);
    return direction * sign(dot(direction, normal));
}

[numthreads(8,8,1)]
void reset(uint3 id : SV_DispatchThreadID) {
    int index = id.x + id.y * width;
    light[index] = float3(0, 0, 0);
}

RayHit testSphere(Ray ray, Sphere sphere) {
    RayHit result;
    result.hit = false;
    float3 ap = sphere.position-ray.origin;
    float b =  2 * dot(ap, ray.direction);
    float c = dot(ap,ap)-sphere.radius * sphere.radius;
    float D = b*b - 4*c;
    if (D < 0) {
        return result;
    }
    float lambda = (b - sqrt(D))/2;
    result.hit = lambda > 0;
    float3 x = ray.origin + lambda * ray.direction;
    result.normal = normalize(x-sphere.position);
    result.position = x;
    result.distance = lambda;
    result.material = materials[sphere.material];
    return result;
}

RayHit testFloor(Ray ray) {
    RayHit result;
    result.hit = ray.direction.y < 0;
    result.distance = -ray.origin.y / ray.direction.y;
    result.position = ray.origin + result.distance * ray.direction;
    result.normal = up;
    float xRemainder = abs(fmod(result.position.x, 2.0));
    float zRemainder = abs(fmod(result.position.z, 2.0));
    if (xRemainder < 0.05 || xRemainder > 1.95 || zRemainder < 0.05 || zRemainder > 1.95) {
        result.material = materials[1];
    } else {
        result.material = materials[0];
    }
    return result;
}


void test(inout RayHit hit, RayHit test)  {
    if (test.hit && test.distance < hit.distance) {
        hit.hit = true;
        hit.position = test.position;
        hit.distance = test.distance;
        hit.material = test.material;
        hit.normal = test.normal;
    }
}

RayHit cast(Ray ray) {
    Material defaultMaterial;
    defaultMaterial.color = float4(0,0,0,0);
    RayHit hit;
    hit.distance = 10000.0;
    hit.hit = false;
    hit.material = defaultMaterial;
    hit.position = up;
    hit.normal = up;
    for (int i = 0; i < sphereCount; i++) {
        test(hit, testSphere(ray, spheres[i]));
    }
    test(hit, testFloor(ray));
    return hit;
}

float3 environmentLight(float3 direction) {
    float3 gradient = lerp(float3(.7,.7,1), float3(0,0,1), dot(direction, up));
    float3 sun = float3(1,1,1) * pow(max(0, dot(direction, sunDirection)), 20) * sunStrength;
    return gradient + sun;
}

float3 findColor(Ray ray, inout uint seed) {
    float3 lightAmount = float3(1,1,1);
    for (int i = 0; i <= bounces; i++) {
        RayHit hit = cast(ray);
        if (!hit.hit) {
            lightAmount *= environmentLight(ray.direction);
            return lightAmount.rgb;
        }
        ray.origin = hit.position;
        float3 specularDirection = reflect(ray.direction, hit.normal);
        float3 diffuseDirection = normalize(hit.normal + randomDirection(seed));
        ray.direction = lerp(diffuseDirection, specularDirection, hit.material.specular);;
        lightAmount *= hit.material.color.rgb;
    }
    return float3(0,0,0);
}

int startSeed;

[numthreads(8,8,1)]
void trace(uint3 id : SV_DispatchThreadID) {
    int index = id.x + id.y * width;
    uint seed = index + startSeed;
    float2 screenPosition = (id.xy / float2(width, height) * 2 - float2(1, 1)) * float2(float(width)/float(height), 1);
    float3 left = normalize(cross(up, viewDirection));
    float3 cameraUp = normalize(cross(viewDirection, left));
    float3 pixelDirection = normalize(viewDirection + screenPosition.x * left + screenPosition.y * cameraUp);
    Ray ray;
    ray.origin = position;
    ray.direction = pixelDirection;
    light[index] += findColor(ray, seed);
}
